<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Reveal.js</title>
        <link rel="stylesheet" href="reveal.css">
        <link rel="stylesheet" href="default.css" id="theme">
    </head>
    <body>
        <div class="reveal">
            <div class="slides"><section undefined data-markdown><script type="text/template"># SCALA SYDNEY
`import scala.language.experimental.{macros => magic}`
</script></section><section undefined data-markdown><script type="text/template">
### Hi, My name is Laurence and I'm a Scala-holic
</script></section><section undefined data-markdown><script type="text/template">
## Contents

1. What are Macros?
2. How do we generate code?
3. Example
4. Pros, Cons and Questions
</script></section><section undefined data-markdown><script type="text/template">
## What are Scala Macros?

Scala Macros let you to generate **type-safe** code at compile-time.*
<div>
<small>* a bunch of other stuff which is coming in later releases.</small>
</div>
</script></section><section undefined data-markdown><script type="text/template">
## Quick Example (Normal Scala)
    
    val test = 123

    def log(fieldName: String, value: AnyRef) : String = {
      // this is what we will be generating during compilation.
      log.info(s"{fieldName} -> {value}")
    }

    log("test", test)

    => "test -> 123"
</script></section><section undefined data-markdown><script type="text/template">
## How we want to write it

    val test = 123

    macroLog(test)

    => "test -> 123"
</script></section><section undefined data-markdown><script type="text/template">
## As a Macro

    val test = 123

    // Our Macro Definition.
    def betterLog(field: AnyRef) : String = 
      macro codeGenerator

    def codeGenerator(c: Context)(field: c.Expr[AnyRef]) : c.Expr[String] = {
      // now generate the code!
      ...
    }

    // Using our Macro
    betterLog(test) // the generated code is swapped in here.

    => "test -> 123"
</script></section><section undefined data-markdown><script type="text/template">
## Scala Macros are Just Scala

- Completely type-safe.
- **Macros must be compiled in a separate project.**
</script></section><section undefined data-markdown><script type="text/template">
## So how do we generate code?

We manipulate the **abstract syntax tree**.

E.g. `plus(1, 2)`

- Directly
      
      Apply("plus", 
        List(
          Literal(Constant(1)), 
          Literal(Constant(2))
      ))

- Reify

      reify {
        plus(1, 2)
      }

- Quasiquotes (coming soon)
</script></section><section undefined data-markdown><script type="text/template">
## Direct Manipulation

    Apply(
      TypeApply(
        Select(
          Select(
            Ident(newTermName("collection")), newTermName("Seq")
            ), newTermName("apply")
          ),
        List(Ident(newTypeName("Integer")))
      ),
      List(Literal(Constant(1)), Literal(Constant(2)), Literal(Constant(3)))
    )
</script></section><section undefined data-markdown><script type="text/template">
## Direct Manipulation

    Apply(
      TypeApply(
        Select(
          Select(
            Ident(newTermName("collection")), newTermName("Seq")
            ), newTermName("apply")
          ),
        List(Ident(newTypeName("Integer")))
      ),
      List(Literal(Constant(1)), Literal(Constant(2)), Literal(Constant(3)))
    )

`Seq(1, 2, 3)`
</script></section><section undefined data-markdown><script type="text/template">
## Reify

    val ast = context.reify {
      import scalaz.Scalaz._

      generatedValidationResults.splice
        .foldLeft(Valid : ValidationResult)(_ |+| _)
    }

becomes
    
    // ast =>
    Expr(Block(List(
    Import(Ident(scalaz.Scalaz), List(ImportSelector(nme.WILDCARD, 1975, null, -1)))),
    Apply(Apply(Select(Apply(
    TypeApply(Select(Select(Ident(newTermName("collection")), newTermName("Seq")), newTermName("apply")), List(Ident(newTypeName("ValidationResult")))),
    List(Apply(Select(Apply(TypeApply(Select(Ident(newTermName("Validatable")), newTermName("apply")), List(Ident(java.lang.String))), List()), newTermName("validate")), List(Select(Ident(newTermName("obj")), newTermName("name")))), Apply(Select(Apply(TypeApply(Select(Ident(newTermName("Validatable")), newTermName("apply")), List(Ident(java.lang.String))), List()), newTermName("validate")), List(Select(Ident(newTermName("obj")), newTermName("reaction")))))), newTermName("foldLeft")), 
    List(Typed(Ident(Valid), Ident(ValidationResult)))), 
    List(Function(List(ValDef(Modifiers(PARAM | SYNTHETIC), newTermName("x$3"), TypeTree(), EmptyTree), 
    ValDef(Modifiers(PARAM | SYNTHETIC), newTermName("x$4"), TypeTree(), EmptyTree)), Apply(Select(Apply(Apply(Select(Ident(scalaz.Scalaz), newTermName("ToSemigroupOps")), List(Ident(newTermName("x$3")))), List(Select(Ident(ValidationResult), newTermName("monoid")))), newTermName("$bar$plus$bar")), List(Ident(newTermName("x$4")))))))))
</script></section><section undefined data-markdown><script type="text/template">
## Contents

1. What are Macros?
2. How do we generate code?
3. **Example**
4. Pros, Cons and Questions
</script></section><section undefined data-markdown><script type="text/template">
# One Example

## Working with bad APIs 
</script></section><section undefined data-markdown><script type="text/template">
## Send This.

    case class Person(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String,
      dateOfBirth: Date,
      allergies: Seq[Allergy]
    )

    => Person("Laurence", "Rouesnel", ...)
</script></section><section undefined data-markdown><script type="text/template">
## Welcome to SimpleService

    type Id = Long
    type Result = Long
    type Path = String
    type SessionId = Long

    def createSession() : SessionId

    def createBusinessObject(sessionId: SessionId, 
                             type: String, 
                             path: Path = "/") : Id

    def setBusinessObjectValue(sessionId: SessionId, 
                               instance: Id, 
                               name: String, 
                               value: String) : Result

    def getPath(sessionId: SessionId, instance: Id) : Path

    def destroySession(sessionId: SessionId) : Result
</script></section><section undefined data-markdown><script type="text/template">
## Usage
    
    val service = ...
    val session = ...

    val name = Name("Laurence", ...)

    val obj = name.toSimpleObject(service, session)

    session.send(obj)
</script></section><section undefined data-markdown><script type="text/template">
## Naive Implementation
    
    case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String
    ) {

      def toSimpleObject(service: SimpleService, session: Id) : Path = {
        val objectId = service.createBusinessObject(session, "name")

        service.setBusinessObjectValue(session, objectId, 
          "firstName", firstName)

        service.setBusinessObjectValue(session, objectId, 
          "familyName", familyName)

        service.setBusinessObjectValue(session, objectId, 
          "otherNames", otherNames.mkString(","))

        service.setBusinessObjectValue(session, objectId, 
          "preferedName", preferredName)

        // Object is now ready to send.
        service.getPath(session, objectId)
      }
    }
</script></section><section undefined data-markdown><script type="text/template">
## Goals

- Make it hard to do the wrong thing
- Make errors obvious (visible and quick to detect)
- Embrace DRY (don't repeat yourself) - reduce boilerplate
- Convention over Configuration
</script></section><section undefined data-markdown><script type="text/template">
## What about a nice service wrapper?
    trait SimpleService {
      def createBusinessObject(fields: (String, SimpleFieldValue)*) :
        Either[SimpleError, Path]
    }

    sealed trait SimpleFieldValue {
      def toSimpleString(): String
    }
    case class SimplePrimitive[T](value: T) extends SimpleFieldValue {
      def toSimpleString(): String = value.toString()
    }
    case class SimpleList[T](value: Seq[T]) extends SimpleFieldValue {
      def toSimpleString(): String = value.mkString("|")
    }

    object SimpleFieldValue {
      implicit val string2SimpleString(value: String) : SimpleFieldValue 
        = SimpleFieldValue(value)

      implicit val int2SimpleInt(value: Int) : SimpleFieldValue 
        = SimpleFieldValue(value)

      implicit val stringSeq2SimpleStringList(value: Seq[String]) : SimpleFieldValue 
        = SimpleList(value)
    }
</script></section><section undefined data-markdown><script type="text/template">
## The Wrapper Approach

    case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String
    ) {

      def toSimpleObject(service: SimplerSimpleService, session: Id) 
        = SimplerSimpleService.createBusinessObject(
          "otherNames" -> otherNames,
          "familyName" -> firstName,
          "firstName" -> familyName,
          "preferredName" -> preferredName
        )
    }

### Usage
    val name = Name(...)
    service.send(
      name.toSimpleObject(service, session)
    )
</script></section><section undefined data-markdown><script type="text/template">
## The Macro Approach

    type SimpleObjectBuilder[T] = 
      (T) => (SimpleService, SessionId, Path) => Either[SimpleError, Unit]

    object SimpleObjectBuilder {
      def apply[T] : SimpleObjectBuilder = macro ...
    }

    case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String
    )

### Usage 

    val name = Name(...)
    service.send(
      SimpleObjectBuilder[Name](name)
    )
</script></section><section undefined data-markdown><script type="text/template">
### From This
  case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String
    )

### Generate a SimpleObjectBuilder:
  (obj: Name) => (SimpleService, SessionId, Path) => {
      val objectId = service.createBusinessObject(session, "name")

      service.setBusinessObjectValue(session, objectId, 
        "firstName", obj.firstName)

      service.setBusinessObjectValue(session, objectId, 
        "familyName", obj.familyName)

      service.setBusinessObjectValue(session, objectId, 
        "otherNames", obj.otherNames.mkString("|"))

      service.setBusinessObjectValue(session, objectId, 
        "preferredName", obj.preferredName)

      // Object is now ready to send.
      service.getPath(session, objectId)
    }
    }

</script></section><section undefined data-markdown><script type="text/template">
# First Steps

    object SimpleObjectBuilder {
      def apply[T] : SimpleObjectBuilder[T] 
        = macro Macros.generateObjectBuilder[T]
    }

    object Macros {
      def generateObjectBuilder[T: c.WeakTypeTag](c: Context)
        : c.Expr[SimpleObjectBuilder[T]] = {

        import c.universe._

        ...

        null
      }
    }
</script></section><section undefined data-markdown><script type="text/template">
## Getting a reference to the type.

  case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String
    )

  SimpleObjectBuilder[Name]

### Macro

    import c.universe._
    
    // Get a reference to the given type (i.e. Name).
    val typeConstructor = weakTypeOf[T]

    val parameters = typeConstructor.declarations
      .filter(_.isTerm)
      .map(_.asTerm)
      .filter(term => term.isVal || term.isVar)
</script></section><section undefined data-markdown><script type="text/template">
## Slow down you're going too fast.

    class SimpleServiceSpec extends Specification { def is = s2"""
      SimpleService is badly written            ${ok}

      Debug Function                            ${debugFunction}
      """

        def debugFunction = {

          val builder = SimpleObjectBuilder[Name]

          ok
        }

      }

</script></section><section undefined data-markdown><script type="text/template">
## Add a few `println`'s
    
    println(weakTypeOf[T].declarations)

    => Scope{
      val firstName: String;
      private[this] val firstName: String;
      val familyName: String;
      private[this] val familyName: String;
      val otherNames: Seq[String];
      private[this] val otherNames: Seq[String];
      val preferredName: String;
      private[this] val preferredName: String;
      def <init>(firstName: String,familyName: String,otherNames: Seq[String],preferredName: String): Name;
      def copy(firstName: String,familyName: String,otherNames: Seq[String],preferredName: String): Name;
      def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance;
      def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance;
      def copy$default$3: Seq[String] @scala.annotation.unchecked.uncheckedVariance;
      def copy$default$4: String @scala.annotation.unchecked.uncheckedVariance;
      override def productPrefix: String;
      def productArity: Int;
      def productElement(x$1: Int): Any;
      override def productIterator: Iterator[Any];
      def canEqual(x$1: Any): Boolean;
      override def hashCode(): Int;
      override def toString(): String;
      override def equals(x$1: Any): Boolean
    }
</script></section><section undefined data-markdown><script type="text/template">
      service.setBusinessObjectValue(session, objectId, 
        "firstName", obj.firstName)

      service.setBusinessObjectValue(session, objectId, 
        "familyName", obj.familyName)

      service.setBusinessObjectValue(session, objectId, 
        "otherNames", obj.otherNames.mkString("|"))

      service.setBusinessObjectValue(session, objectId, 
        "preferredName", obj.preferredName)
</script></section><section undefined data-markdown><script type="text/template">
## Filtering out everything else

    // Get the parameter symbols of the constructor.
    val parameters = typeConstructor.declarations
      .filter(_.isTerm)
      .map(_.asTerm)
      .filter(term => term.isVal || term.isVar)

    println(parameters)

    => List(
        value firstName, 
        value familyName, 
        value otherNames, 
        value preferredName
      )
</script></section><section undefined data-markdown><script type="text/template">
## Getting the field names

    def toDebugString(obj: AnyRef) = s"'${obj}': ${obj.getClass}"

    println(parameters.map(_.name).map(toDebugString))


    => List(
        'firstName ': class scala.reflect.internal.Names$TermName_R, 
        'familyName ': class scala.reflect.internal.Names$TermName_R, 
        'otherNames ': class scala.reflect.internal.Names$TermName_R, 
        'preferredName ': class scala.reflect.internal.Names$TermName_R
    )
</script></section><section undefined data-markdown><script type="text/template">
## Reification

    val createObject = reify {
      (instance: T) =>
      (service: SimpleService, sessionId: SessionId, path: Path) => {
        val instanceId = service.createBusinessObject(sessionId, "objtype", path)

        service.setBusinessObjectValue(sessionId, instanceId,
          "name", "value")

        service.getPath(sessionId, instanceId)
      }
    }
</script></section><section undefined data-markdown><script type="text/template">
## println to the rescue
      
      println(createObject)

      => Expr[Name => ((simpleservice.SimpleService, simpleservice.SimpleService.SessionId, simpleservice.SimpleService.Path) => simpleservice.SimpleService.Path)]
        (((instance: Name) => 
        ((service: SimpleService, sessionId: SimpleService.SessionId, path: SimpleService.Path) => {

        val instanceId = service.createBusinessObject(sessionId, path, service.createBusinessObject$default$3);
        
        service.setBusinessObjectValue(sessionId, instanceId, "name", "value");
        
        service.getPath(sessionId, instanceId)
      })))
</script></section><section undefined data-markdown><script type="text/template">
## With a few tweaks.
      
      println(c.universe.showRaw(createObject))

      => Expr(Function(List(ValDef(Modifiers(PARAM), 
      newTermName("instance"), TypeTree(), EmptyTree)), 
      Function(List(ValDef(Modifiers(PARAM), newTermName("service"), 
      Ident(simpleservice.SimpleService), EmptyTree), ValDef(Modifiers(PARAM), 
      newTermName("sessionId"), Select(Ident(simpleservice.SimpleService), newTypeName("SessionId")), 
      EmptyTree), ValDef(Modifiers(PARAM), newTermName("path"), 
      Select(Ident(simpleservice.SimpleService), newTypeName("Path")), 
      EmptyTree)), Block(List(ValDef(Modifiers(), newTermName("instanceId"), TypeTree(), 
      Apply(Select(Ident(newTermName("service")), newTermName("createBusinessObject")), 
      List(Ident(newTermName("sessionId")), Literal(Constant("objType")), 
      Ident(newTermName("path"))))), Apply(Select(Ident(newTermName("service")), 
      newTermName("setBusinessObjectValue")), List(Ident(newTermName("sessionId")), 
      Ident(newTermName("instanceId")), 
      Literal(Constant("name")), Literal(Constant("value"))))), 
      Apply(Select(Ident(newTermName("service")), newTermName("getPath")), 
      List(Ident(newTermName("sessionId")), Ident(newTermName("instanceId"))))))))
</script></section><section undefined data-markdown><script type="text/template">
## More experimenting.

    case class Test(a: Int, b: String)

    val test = reify {
      val instance : Test = Test(1, "b")
      instance.a
    }

    println(c.universe.showRaw(test))

    => Expr(Block(List(
      ValDef(Modifiers(), newTermName("instance"), TypeTree(), 
        Apply(
          Select(Ident(newTermName("Test")), newTermName("apply")), 
          List(Literal(Constant(1)), Literal(Constant("b")))))
        ), 

      Select(Ident(newTermName("instance")), newTermName("a")))
    )
</script></section><section undefined data-markdown><script type="text/template">
## Adding in SimpleService

    case class Test(a: Int, b: String)

    val test = reify {
      val instance : Test = null
      val service : SimpleService = null
      service.setBusinessObjectValue(0, 0, "b", instance.b)
    }

    println(c.universe.showRaw(test))
</script></section><section undefined data-markdown><script type="text/template">
## Now its making sense.

    Expr(Block(List(
      
      // val instance : Test = null
      ValDef(Modifiers(), newTermName("instance"), TypeTree(), Literal(Constant(null))), 

      // val service : SimpleService = null
      ValDef(Modifiers(), newTermName("service"), Ident(simpleservice.SimpleService), Literal(Constant(null)))), 


      // service.setBusinessObjectValue(0, 0, "b", instance.b)
      Apply(
        Select(Ident(newTermName("service")), newTermName("setBusinessObjectValue")), 

        List(
          Literal(Constant(0)), 
          Literal(Constant(0)), 
          Literal(Constant("b")), 
          Select(Ident(newTermName("instance")), newTermName("b"))
        )
      )
    ))
</script></section><section undefined data-markdown><script type="text/template">
      service.setBusinessObjectValue(sessionId, instanceId, 
        "firstName", instance.firstName)

      service.setBusinessObjectValue(session, instanceId, 
        "familyName", instance.familyName)

      service.setBusinessObjectValue(session, instanceId, 
        "otherNames", instance.otherNames.mkString("|"))

      service.setBusinessObjectValue(session, instanceId, 
        "preferredName", instance.preferredName)
</script></section><section undefined data-markdown><script type="text/template">
## A bit of copy-pasting.

    val appliedParameters = parameters.map(p => {
      Apply(
        Select(Ident(newTermName("service")), newTermName("setBusinessObjectValue")),
        List(
          Ident(newTermName("sessionId")),
          Ident(newTermName("instanceId")),
          Ident(p.name.toTermName),
          Select(
            Ident(newTermName("instance")),
            p
          ) : Tree
        )
      )
    })

</script></section><section undefined data-markdown><script type="text/template">
## Check with println

    println(appliedParameters)

    => List(
        service.setBusinessObjectValue(sessionId, instanceId,
          firstName , instance.firstName), 

        service.setBusinessObjectValue(sessionId, instanceId,
          familyName , instance.familyName),

        service.setBusinessObjectValue(sessionId, instanceId,
          otherNames , instance.otherNames),

        service.setBusinessObjectValue(sessionId, instanceId,
          preferredName , instance.preferredName)
    )
</script></section><section undefined data-markdown><script type="text/template">
## But we wanted Strings

    val appliedParameters = parameters.map(p => {
      Apply(
        Select(Ident(newTermName("service")), newTermName("setBusinessObjectValue")),
        List(
          Ident(newTermName("sessionId")),
          Ident(newTermName("instanceId")),
          Literal(Constant(p.name.toTermName.toString.trim)) : Tree,
          Select(
            Ident(newTermName("instance")),
            p
          ) : Tree
        )
      )
    })
</script></section><section undefined data-markdown><script type="text/template">
## Checking again.

    println(appliedParameters)

    => List(
        service.setBusinessObjectValue(sessionId, instanceId,
          "firstName", instance.firstName), 

        service.setBusinessObjectValue(sessionId, instanceId, 
          "familyName", instance.familyName), 

        service.setBusinessObjectValue(sessionId, instanceId, 
          "otherNames", instance.otherNames), 

        service.setBusinessObjectValue(sessionId, instanceId, 
          "preferredName", instance.preferredName)
      )
</script></section><section undefined data-markdown><script type="text/template">
## An updated CreateObject

    val createObject = reify {
      (instance: T) =>
      (service: SimpleService, sessionId: SessionId, path: Path) => {
        val instanceId = service.createBusinessObject(sessionId, "objType", path)

        c.Expr[Unit](
          Block(appliedParameters.toSeq: _*)
        ).splice

        service.getPath(sessionId, instanceId)
      }
    }
</script></section><section undefined data-markdown><script type="text/template">
## Checking with PrintLn

    Expr[Name => ((simpleservice.SimpleService, simpleservice.SimpleService.SessionId, simpleservice.SimpleService.Path) => simpleservice.SimpleService.Path)](((instance: Name) => ((service: SimpleService, sessionId: SimpleService.SessionId, path: SimpleService.Path) => {
      val instanceId = service.createBusinessObject(sessionId, "objType", path);
      {
        service.setBusinessObjectValue(sessionId, instanceId, 
          "firstName", instance.firstName);

        service.setBusinessObjectValue(sessionId, instanceId, 
          "familyName", instance.familyName);

        service.setBusinessObjectValue(sessionId, instanceId, 
          "otherNames", instance.otherNames);

        service.setBusinessObjectValue(sessionId, instanceId, 
          "preferredName", instance.preferredName)
      };
      service.getPath(sessionId, instanceId)
    })))
</script></section><section undefined data-markdown><script type="text/template">
## Oh no

    [error] /Users/laurencer/src/scala-syd-talk/examples/src/test/scala/SimpleServiceSpec.scala:18: 
      value firstName  is not a member of Name

    [error]     val builder = SimpleObjectBuilder[Name]

A fix (notice the double space after firstName):

    Select(
      Ident(newTermName("instance")),
      newTermName(p.name.toTermName.toString.trim)
    ) : Tree

What Changed?

    p -> newTermName(p.name.toTermName.toString.trim)
</script></section><section undefined data-markdown><script type="text/template">
## We forgot something.

    [error] /Users/laurencer/src/scala-syd-talk/examples/src/test/scala/SimpleServiceSpec.scala:18: type mismatch;

    [error]  found   : Seq[String]
    [error]  required: String

    [error]     val builder = SimpleObjectBuilder[Name]

    // Unchangeable API.
    def setBusinessObjectValue(sessionId: SessionId, 
       instance: Id, 
       name: String, 
       value: String // Wants a String 
  ) : Result

    case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String], // Not a String :(
      preferredName: String
    )
</script></section><section undefined data-markdown><script type="text/template">
## To Fix This We Need Better Type Handling

- Different behaviours for different types.
- Nicer errors if we give it a type it cannot handle.
- Customise the behaviour through annotations.
</script></section><section undefined data-markdown><script type="text/template">
## We need some annotations.

These will change how our code gets generated.

    case class ObjectType(objType: String) 
      extends scala.annotation.StaticAnnotation

    case class Ignore
      extends scala.annotation.StaticAnnotation

    case class ObjectPath(path: String)
      extends scala.annotation.StaticAnnotation
</script></section><section undefined data-markdown><script type="text/template">
## Now with Annotations

    @ObjectType("nickname")
    case class Nickname(
      name: String
    )

    @ObjectType("name")
    case class Name(
      firstName: String,
      familyName: String,
      otherNames: Seq[String],
      preferredName: String,
      @Ignore twitterHandle: String,
      @ObjectPath("/nicknames") nickname: Nickname
    )
</script></section><section undefined data-markdown><script type="text/template">
## Rewriting to use the Constructor

NB. Annotations are on the constructor arguments - not the fields.

  // Usage: SimpleObjectBuilder[Name]
    
    // Get a reference to the constructor of the type.
    val typeConstructor = weakTypeOf[T]

    val constructor = typeConstructor.declarations.collect({
      case MethodSymbolTag(method) if method.isPrimaryConstructor => method
    }).head

    // Get the parameter symbols of the constructor.
    // Filter out any with the @Ignore annotation.
    val parameters = constructor.paramss.head.filter(p =>
      p.annotations.find(_.tpe =:= typeOf[Ignore]).isEmpty
    )
</script></section><section undefined data-markdown><script type="text/template">
## Type-based behaviour

    // List of types we can directly serialise
    val acceptableTypes = List(
      typeOf[Int],
      typeOf[String],
      typeOf[Long]
    )
    
    def isAcceptableType(pType: Type) = 
      acceptableTypes.foldRight(false)((typ, memo) => memo || pType <:< typ)

    val appliedParameters = parameters.map(p => {

      if (p.typeSignature <:< typeOf[Seq[_]]) {
        generateSequenceSetter(p)
      } else if (isAcceptableType(p.typeSignature)) {
        generateValueSetter(p)
      } else {
        val pathAnnotation = p.annotations.find(_.tpe =:= typeOf[ObjectPath])
        pathAnnotation match {
          case Some(pathAnnotation) =>
            generateObjectSetter(p, pathAnnotation.scalaArgs.head)
          case None => {
            c.abort(c.enclosingPosition, s"Complex object in field `${p.name}` on type `${typeConstructor}` does not have @ObjectPath annotation. Use @Ignore if you don't want it serialized.")
          }
        }
      }
    })
</script></section><section undefined data-markdown><script type="text/template">
## Win.

    Expr[Name => ((simpleservice.SimpleService, simpleservice.SimpleService.SessionId, simpleservice.SimpleService.Path) => simpleservice.SimpleService.Path)](((instance: Name) => ((service: SimpleService, sessionId: SimpleService.SessionId, path: SimpleService.Path) => {
      val instanceId = service.createBusinessObject(sessionId, "objType", path);
      {
        service.setBusinessObjectValue(sessionId, instanceId, 
          "firstName", instance.firstName);
        
        service.setBusinessObjectValue(sessionId, instanceId, 
          "familyName", instance.familyName);
        
        service.setBusinessObjectValue(sessionId, instanceId, 
          "otherNames", instance.otherNames.mkString("|"));
        
        service.setBusinessObjectValue(sessionId, instanceId, 
          "preferredName", instance.preferredName);
        
        SimpleObjectBuilder.apply[Nickname](instance.nickname)(service, sessionId, "/nickname")
      };
      service.getPath(sessionId, instanceId)
    })))
</script></section><section undefined data-markdown><script type="text/template">
## Advantages over Reflection

- Reflection is really slow.
- Reflection is brittle - it breaks at run time and not at compile time.
- Java Reflection doesn't work well with Scala types.
</script></section><section undefined data-markdown><script type="text/template">
## Advantages over Hand-Written Code

- Compile time errors if you screw up.
- No duplication of code/field names.
</script></section><section undefined data-markdown><script type="text/template">
# Why not macros?
</script></section><section undefined data-markdown><script type="text/template">
## Magic.

- Hard to read and debug.
- Painful for end-users when they don't work.
- Time-consuming to write.
</script></section><section undefined data-markdown><script type="text/template">
# Thank you!

## Questions?</script></section></div>
        </div>
        <script src="head.min.js"></script>
        <script src="reveal.js"></script>
        <script>
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                theme: Reveal.getQueryHash().theme,
                transition: Reveal.getQueryHash().transition || 'default',
                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
                    { src: 'markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } }
                ]
            });
        </script>
        <script src="highlight.min.js">
        <link rel="stylesheet" href="zenburn.min.css">
    </body>
</html>